{"meta":{"title":"CHUANWISE","subtitle":"椽子的博客 (｡･∀･)ﾉﾞ","description":"Hi here👏👏","author":"Chuanwise","url":"https://chuanwise.github.io","root":"/"},"pages":[{"title":"这里好像是「椽子无处不在」的例外 Σ(っ °Д °;)っ","date":"2021-04-11T16:06:09.438Z","updated":"2021-04-11T16:06:09.438Z","comments":false,"path":"/404.html","permalink":"https://chuanwise.github.io/404.html","excerpt":"","text":"(；′⌒`) 你来到了没有椽子的荒漠 返回主页"},{"title":"关于","date":"2021-04-11T15:08:01.967Z","updated":"2021-04-11T15:08:01.967Z","comments":false,"path":"about/index.html","permalink":"https://chuanwise.github.io/about/index.html","excerpt":"","text":"椽子，Chuanwise，软件工程学生，单身。初二沉迷编程和古建筑至今。 成就 在编程上，个人感觉没有非常大的成就，但是会（起码从现在开始）努力学习。 在古建筑上可能稍有成就。成立了 Minecraft 古建筑教学组织太学，也和大家一起发布了一些颇受好评的作品。 联系我 QQ：1437100907 微信号：Chuanwise1437100907 邮箱：chuanwise@qq.com"},{"title":"分类","date":"2021-04-11T12:35:26.954Z","updated":"2021-04-11T12:35:26.954Z","comments":false,"path":"categories/index.html","permalink":"https://chuanwise.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-11T12:35:26.955Z","updated":"2021-04-11T12:35:26.955Z","comments":true,"path":"links/index.html","permalink":"https://chuanwise.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-04-11T12:35:26.953Z","updated":"2021-04-11T12:35:26.953Z","comments":false,"path":"books/index.html","permalink":"https://chuanwise.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-04-11T12:35:26.955Z","updated":"2021-04-11T12:35:26.955Z","comments":false,"path":"repository/index.html","permalink":"https://chuanwise.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-11T12:35:26.956Z","updated":"2021-04-11T12:35:26.956Z","comments":false,"path":"tags/index.html","permalink":"https://chuanwise.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"小明框架开发文档","slug":"小明框架开发文档","date":"2021-04-18T23:28:57.000Z","updated":"2021-05-15T15:41:23.347Z","comments":true,"path":"2021/04/19/小明框架开发文档/","link":"","permalink":"https://chuanwise.github.io/2021/04/19/%E5%B0%8F%E6%98%8E%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3/","excerpt":"","text":"本文对应 Github 项目：小明框架 小明机器人是一款基于 Mirai 的插件化、便于上手、简单小巧的通用 QQ 机器人框架。 QQ群：1028959718 作者：椽子 请遵循 Apache-2.0 开源协议使用小明机器人框架。 组件介绍 本项目有三个组件，api、core 和 host。 api 是一组小明调用标准，core 是对 api 的一种规范实现，host 是小明本体的启动器。 前置知识 Java 基础知识：必须 Maven 用法：必须 Git：锦上添花 快速开始 你可以下载最新的 RELEASE，将之添加在项目的库中，或使用 mvn 安装 core 后，在 pom.xml 中添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.chuanwise&lt;/groupId&gt; &lt;artifactId&gt;xiaoming-core&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 随后创建插件主类。插件主类必须实现 com.chuanwise.xiaoming.api.plugin.XiaomingPlugin 接口。你可以选择继承自内核的实现 com.chuanwise.xiaoming.core.plugin.XiaomingPluginImpl，例如： 1234567891011package com.chuanwise.xiaoming.example;import com.chuanwise.xiaoming.api.user.XiaomingUser;import com.chuanwise.xiaoming.core.plugin.XiaomingPluginImpl;/** * 插件主类示例 * @author Chuanwise */public class ExamplePlugin extends XiaomingPluginImpl &#123;&#125; 这个插件已经能被小明加载了，但还没有任何功能。我们先将其打包运行吧！ 打包运行 请在资源文件夹 resources 中创建 plugin.json，内容如下： 1234567&#123; &quot;name&quot;: &quot;example-plugin-name&quot;, &quot;main&quot;: &quot;com.chuanwise.xiaoming.example.ExamplePlugin&quot;, &quot;author&quot;: &quot;Chuanwise&quot;, &quot;version&quot;: &quot;1.0.TEST&quot;, &quot;fronts&quot;: [ &quot;lexicons&quot; ]&#125; name：插件名 选填，默认值为 jar 文件名。建议自行设计一个名字。 main：插件主类名 必填，值为插件主类名。 version：版本 选填，默认值为 (unknown) fronts：前置插件名列表 选填，默认值为空。小明只会在加载完全部 fronts 里的插件后加载本插件。 除上述内容外你还可以增加其他的键，可以在插件主类中获得他们的值。 将此插件打包为 jar 文件后放在 小明根目录/plugins，重新启动小明或执行小明指令 #加载 &lt;你的插件名&gt;（此热加载功能尚在实现中）即可加载本插件。 聊天消息处理 小明的聊天消息可分三类：群聊、私聊和群临时会话。它们都可以通过下述方式处理： 单句聊天消息 通过重写 XiaomingPlugin 类中的 onMessage 方法，可以实现对所有类型聊天消息的监听。例如： 1234567891011121314151617181920package com.chuanwise.xiaoming.example;import com.chuanwise.xiaoming.api.user.XiaomingUser;import com.chuanwise.xiaoming.core.plugin.XiaomingPluginImpl;/** * 插件主类示例 * @author Chuanwise */public class ExamplePlugin extends XiaomingPluginImpl &#123; @Override public boolean onMessage(XiaomingUser user) &#123; if (user.inGroup()) &#123; user.sendMessage(user.getMessage()); return true; &#125; else &#123; return false; &#125; &#125;&#125; 上述例子展示了给用户发消息的方法 user.sendMessage(...)、判断用户当前位置的方法 user.inGroup() 和获得当前用户输入的方法：user.getMessage()。其功能是复读所有小明所在的群消息。 功能更强大的监听方式 小明支持上下文相关的消息交互。例如：用户输入小明在吗，小明回答在，啥事，用户继续输入没事或其他内容，小明视具体回答回复。 要实现这个功能，需要一个继承自 com.chuanwise.xiaoming.core.interactor.message.MessageInteractorImpl 的类作为交互器。在其中使用com.chuanwise.xiaoming.api.annotation.Filter注解该方法的触发信息。例如： 1234567891011121314151617181920212223242526package com.chuanwise.xiaoming.example.interactor;import com.chuanwise.xiaoming.api.annotation.Filter;import com.chuanwise.xiaoming.api.user.XiaomingUser;import com.chuanwise.xiaoming.core.interactor.message.MessageInteractorImpl;import java.util.Objects;/** * 消息交互器示例 * @author Chuanwise */public class MessageInteractorTest extends MessageInteractorImpl &#123; // 收到 &quot;小明在吗&quot; 的消息时，该方法响应 @Filter(&quot;小明在吗&quot;) public void onMessage(XiaomingUser user) &#123; user.sendMessage(&quot;在，啥事&quot;); final String nextInput = user.nextInput(); if (Objects.equals(nextInput, &quot;没事&quot;)) &#123; user.sendMessage(&quot;彳亍吧，下次有事记得叫我哦&quot;); &#125; else &#123; // 有事时的操作 &#125; &#125;&#125; 这类响应聊天消息的方法，统称交互方法。存在交互方法的类，都是交互器。在插件启动时，你需要注册该交互器的实例。例如： 1234567891011121314151617package com.chuanwise.xiaoming.example;import com.chuanwise.xiaoming.api.user.XiaomingUser;import com.chuanwise.xiaoming.core.plugin.XiaomingPluginImpl;import com.chuanwise.xiaoming.example.interactor.MessageInteractorTest;/** * 插件主类示例 * @author Chuanwise */public class ExamplePlugin extends XiaomingPluginImpl &#123; @Override public void onEnable() &#123; // 注册一个交互器 getXiaomingBot().getInteractorManager().register(new MessageInteractorTest(), this); &#125;&#125; 交互方法起码要有一个 Filter（过滤器）注解。它有两种形式： @Filter(&quot;文本信息&quot;) @Filter(value = &quot;文本信息&quot;, pattern = FilterPattern.EQUALS) 小明不喜欢那种无条件触发的交互方法，这可能会让小明所在的群非常吵，所以交互方法至少要有一个 Filter。但如果你仍然希望该交互方法被无条件触发，只需要使用@Filter(value = &quot;&quot;, pattern = FilterPattern.STARTS_WITH)。或直接监听聊天消息。 核心 小明由本体和各个组件组成。 小明本体：XiaomingBot 几乎在所有的类下，你都可以通过 getXiaomingBot() 获得该类所属的小明机器人本体。本体提供了大量组件的获取方法，方便你进行各类操作。 小明本体的方法主要是各类组件的引用，即以 get 开头的大部分无参方法。 方法名 组件说明 getUserCallLimitManager() 用户调用限制器 getTextManager() 说明文本管理器 getRegularPreserveManager() 文件定时保存线程 getEventListenerManager() 监听器管理器 getResponseGroupManager() 响应群管理器 getFilePreservableFactory() 文件加载器 getReceiptionistManager() 接待线程管理器 getLicenseManager() 强制验证管理器 getPluginManager() 插件管理器 getInteractorManager() 交互器管理器 getConsoleXiaomingUser() 控制台小明用户 getStatistician() 统计数据管理器 getAccountManager() 账户管理器 getWordManager() 提示语管理器 getPermissionManager() 权限管理器 getService() 小明线程池 getConfig() 小明配置信息 这些组件将在下文逐一介绍。 此外还有一些功能性方法： 方法名 组件说明 load() 重新加载所有小明组件 load(String name) 重新加载指定的小明组件 setMiraiBot() 设置小明核心的 mirai 机器人 getMiraiBot() 获得小明核心的 mirai 机器人 isStop() 判断小明是否停机 start() 启动小明 setConsoleXiaomingUser() 设置小明的控制台用户 execute(Thread thread) 执行一个线程 execute(Runnable runnable) 执行一个线程 stop() 关闭小明 请不要直接使用类似 new Thread(runnable).start(); 的方式执行线程。请采用 getXiaomingBot().execute(runnable) 的方式。只有通过这种方式启动的线程才会收到小明的关闭通知。 小明使用者：XiaomingUser 每一个小明的使用者都是该类的对象，就连控制台也不例外。 XiaomingUser 类有非常多实用方法，主要有三类：发送消息类、接收消息类和其他类。 发送消息类 发送消息类方法有很多的重载形式，返回值皆为 boolean ，表示消息是否被发送成功。倒数两个参数一般是 Object 和 Object...。前者是消息。小明执行它的 toString() 方法得到消息内容。在消息内容中可以存在 &#123;&#125;，将会被按顺序替换为 Object... 中的参数。例如：user.sendPrivateMessage(&quot;小明不能帮你做这件事哦，因为你缺少权限：&#123;&#125;&quot;, permissionNode)，等同于 user.sendPrivateMessage(&quot;小明不能帮你做这件事哦，因为你缺少权限：&quot; + permissionNode)。 方法原型 说明 sendError(Object, Object...) 给当前用户发送错误消息 sendWarn(Object, Object...) 给当前用户发送警告消息 sendMessage(Object, Object...) 给当前用户发送普通消息 sendPrivateError(Object, Object...) 给当前用户私发错误消息 sendPrivateWarn(Object, Object...) 给当前用户私发警告消息 sendPrivateMessage(Object, Object...) 给当前用户私发普通消息 上述方法是通常使用的发送消息的方法。此外你还可以使用下列方法： 方法原型 说明 sendGroupMessage(Object, Object...) 如果小明为群聊或群临时会话用户，则向其对应的群中发送消息 sendGroupMessage(long, Object, Object...) 在指定的群中发消息 sendGroupAtMessage(Object, Object...) 先 @ 用户，再给用户发消息 sendGroupAtMessage(long, long, Object, Object...) 在指定的群中先 @ 特定用户，再给其发消息 sendPrivateMessage(Object, Object...) 给当前小明用户发送私聊消息 sendPrivateMessage(long, Object, Object...) 给指定的用户发送私聊消息 sendPrivateMessage(long, long, Object, Object...) 给指定的群中的用户发送私聊消息。第一个 long 为群号，第二个为 QQ 号。 接收消息类 返回类型 方法原型 说明 String nextInput() 获得用户在十分钟之内的下一次输入 String nextInput(long) 获得用户在指定时长之内的下一次输入 String nextInput(long, Function) 获得用户在指定时长之内的下一次输入。超时时执行指定的方法。 String nextInput(Function) 获得用户在十分钟之内的下一次输入。超时时执行指定的方法。 默认超时后会退出当前交互器。你可以通过捕捉 InteractorTimeoutException 异常以阻止超时退出。 其他 在发送较长的消息时，使用 StringBuffer 构造字符串存在换行的麻烦。小明内也集成了一个 StringBuffer，用来收集若干次 sendMessage 类消息的输出。与之相关的方法有： 返回类型 方法原型 说明 StringBuffer getBuffer() 获得当前的消息缓冲区 void appendBuffer(String) 在当前消息缓冲区中增加一行文字 void enableBuffer() 接下来让小明将消息存放在缓冲区中 void setUsingBuffer(boolean) 启动或关闭缓冲区 void clearBuffer() 清除缓冲区信息 String getBufferAndClear() 提取缓冲区消息，并清除后关闭缓冲区 boolean isUsingBuffer() 判断当前是否正在使用缓冲区 你可以通过缓冲区机制实现多次输出的合并。例如小明有一个指令是 批处理&lt;remain&gt;，你可以通过类似下面的方法避免频繁发送每次指令执行时的输出： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.chuanwise.xiaoming.core.interactor.core;// import .../** * 全局指令处理器 * @author Chuanwise */public class GlobalCommandInteractor extends CommandInteractorImpl &#123; public static final String BAT_REGEX = &quot;(批处理|bat)&quot;; /** * 批处理指令 * @param user 指令执行者 * @param remain 指令 */ @Filter(BAT_REGEX + &quot;&#123;remain&#125;&quot;) public void onMultipleCommands(XiaomingUser user, @FilterParameter(&quot;remain&quot;) String remain) &#123; final String[] subCommands = remain.split(Pattern.quote(&quot;\\\\n&quot;), 0); // 接下来使用小明缓冲区，将输出到这里 user.enableBuffer(); int commandNumber = 0; try &#123; for (int i = 0; i &lt; subCommands.length; i++) &#123; String command = subCommands[i]; if (command.isEmpty()) &#123; continue; &#125; user.setMessage(command); if (getXiaomingBot().getInteractorManager().onCommand(user)) &#123; commandNumber++; &#125; else &#123; user.sendError(&quot;无效的命令：&#123;&#125;，批处理任务被中断。&quot;, command); break; &#125; &#125; &#125; catch (Exception exception) &#123; user.sendError(&quot;执行&#123;&#125;个指令时出现异常，批处理任务被中断。&quot;); exception.printStackTrace(); &#125; // 提取缓冲区信息，恢复正常输出 final String bufferString = user.getBufferAndClear(); user.sendPrivateMessage(bufferString); if (commandNumber == 0) &#123; user.sendError(&quot;小明没能成功执行任何一个指令&quot;); &#125; else &#123; user.sendMessage(&quot;成功执行了 &#123;&#125; 个指令&quot;, commandNumber); &#125; &#125;&#125; 此外小明还有记录最近几条有效输入记录的功能。它主要用于异常报告，但也可供平时使用。与之相关的方法为： 返回类型 方法原型 说明 List&lt;String&gt; getRecentInputs() 获得最近的几次有效输入 void clearRecentInputs() 清除最近几次有效输入 判断和获取用户会话环境的方法： 返回类型 方法原型 说明 boolean inPrivate() 判断用户当前是否在私聊 boolean inGroup() 判断用户当前是否在群聊 boolean inTemp() 判断用户当前是否在临时会话 Group getGroup() 如果用户当前在临时会话或群聊，获得相关的群 Friend getAsPrivate() 如果此时为私聊，获得私聊会话 Member getAsTempMember() 如果此时为临时会话，获得临时会话 Member getAsGroupMember() 如果此时为群聊，获得群聊会话 ResponseGroup getResponseGroup() 如果此时为临时会话或群聊，获得对应的响应群（临时会话时可能会失败） long getQQ() 获取用户 QQ String getMessage() 获取用户输入 void setMessage(String) 改变用户输入 其他相关方法： 返回类型 方法原型 说明 String getCompleteName() 获取用户全名（包含群号等信息） Receptionist getReceptionist() 获得该用户的接待线程 boolean hasPermission(String[]) 判断用户是否有所需权限 boolean hasPermission(String) 判断用户是否有所需权限 boolean requirePermission(String) 当用户没有所需权限时提醒，并返回 false boolean isBlockPlugin(String) 判断用户是否屏蔽某插件 Account getAccount() 获取该用户在小明这里的账户信息。如果此前无相关信息返回 null Account getOrPutAccount() 获取或新建该用户在小明这里的账户信息 XiaomingBot getXiaomingBot() 获取小明本体 用户调用限制器：UserCallLimitManager 其主要的方法只有两个，分别为： 方法名 说明 getPrivateCallLimiter() 获得最近的私聊调用限制记录 getGroupCallLimiter() 获得最近的群聊调用限制记录 上述方法返回的都是 UserCallLimiter 类型的对象。该类型判断是否到调用限制所用的工具，其方法主要有： 方法名 说明 isTooManySoUncallable(long qq) 判断用户是否因为调用次数过多而达到限制 addCallRecord(long qq) 增加一条新的调用记录 shouldNotice() 判断是否应该提醒用户 uncallable(long qq) 判断用户是否能调用 getCallRecords(long qq) 获得某个用户最近的调用记录。如果无记录返回 null getOrPutCallRecords(long qq) 获得或新增某个用户最近的调用记录 isTooFastSoUncallable(long qq) 判断用户是否因为调用过快而达到限制 getConfig() 获得当前的调用限制配置 setConfig(CallLimitConfig config) 设置新的调用限制配置 过滤器：Filter 过滤器是一个注解，只能标注在方法上。负责验证信息并用于判断触发的交互方法。 参数名 含义 默认值（如果有） value 由下一个参数而定 pattern 过滤方式 FilterPattern.PARAMETER FilterPattern 是过滤方式，是一个枚举类型，其所有可能的取值有： 值 触发交互方法的时机 EQUALS 消息等于 value 时 EQUALS_IGNORE_CASE 消息等于 value （忽略大小写）时 STARTS_WITH 消息以 value 开头时 ENDS_WITH 消息以 value 结尾时 STARTS_REGEX 消息开头匹配正则表达式 value 时 ENDS_REGEX 消息结尾匹配正则表达式 value 时 MATCHES 消息匹配正则表达式 value 时 PARAMETER 消息匹配提取参数的正则表达式 value 时 在使用 PARAMETER 作为过滤方式的过滤器的交互方法中，可以使用 @FilterParameter(&quot;...&quot;) 注解提取参数。例如： 123456public class FilterTestInteractor extends CommandInteractorImpl &#123; @Filter(&quot;禁止&#123;what&#125;&quot;) public void filterTest1(XiaomingUser user, @FilterParameter(&quot;what&quot;) String what) &#123; user.sendMessage(&quot;禁止禁止&#123;&#125;&quot;, what); &#125;&#125; 上述函数的第二个参数使用 @FilterParameter(&quot;what&quot;) 注解，小明将会把过滤器 &#123;what&#125; 处的值填自动填充到这里。例如当输入的消息是 禁止复读 时，what 的值会被设置成 复读。 @FilterParameter 注解还有另一种形式：@FilterParameter(value = &quot;what&quot;, defaultValue = &quot;芜湖&quot;)。其作用是当 @Filter 中的字符串没有出现 &#123;what&#125; 时，使用 &quot;芜湖&quot; 作为该变量的默认值。defaultValue 的默认值为空串 &quot;&quot;。 值得一提的时，使用 @FilterParameter 的注解不一定必须是 String 类型。例如： 12345678910public class FilterTestInteractor extends CommandInteractorImpl &#123; @Filter(&quot;&#123;qq&#125;可爱吗&quot;) public void filterTest3(XiaomingUser user, @FilterParameter(&quot;qq&quot;) long who) &#123; if (who == 1437100907) &#123; user.sendMessage(&quot;当然可爱呀，毕竟是我爸嗷 _(:з」∠)_&quot;); &#125; else &#123; user.sendMessage(&quot;也可爱，但没我爸可爱&quot;); &#125; &#125;&#125; 实际输入时，在 &#123;qq&#125; 的位置可以输入 QQ 号或直接 @ 相关用户。小明会提取对应的 QQ 号，并放在 who 变量中。 你可以通过重写当前交互器类的 onParameter 方法自由地处理此处的参数。该方法的信息为： 返回类型 返回含义 Object 此处应该填入的参数，如果为 null 则匹配不成功 如果为 null，小明会抛出异常并退出该交互器。 参数 含义 XiaomingUser user 当前调用者 Class clazz 当前参数类 String parameterName 参数在 @FilterParameter(&quot;...&quot;) 中的名字 String currentValue 参数当前值 String defaultValue 参数默认值 交互器：Interactor 交互器通过交互方法和用户交互。是小明的主要组件之一。交互器分为两类：指令交互器和消息交互器，其区别在指令交互器多一个自动生成指令格式说明的功能。 交互器内部使用过滤器 @Filter 注解的方法被称为交互方法，是直接和用户交互的工具。在上述讲解过滤器的例子中我们已经了解了一些简单的交互方法，实际上交互方法还可以有除了 XiaomingUser 和使用 @FilterParameter 注解的参数之外的参数： 参数类型 自动填充内容 FilterMatcher 与当前输入匹配的当前交互方法的一个过滤验证器 InteractorMethodDetail 当前交互方法的一些细节 除此之外，你还可以通过重写 onParameter 的另一个实例以自动填充此处的参数。该方法的信息为： 返回类型 返回含义 Object 此处应该填入的参数，如果为 null 则匹配不成功 如果为 null，小明会抛出异常并退出该交互器。 参数 含义 XiaomingUser user 当前调用者 Parameter parameter 当前参数 示例插件 xiaoming-example： (插件示例)[https://github.com/Chuanwise/xiaoming-example] xiaoming-lexicons： (插件示例)[https://github.com/Chuanwise/xiaoming-lexicons]","categories":[{"name":"Java","slug":"Java","permalink":"https://chuanwise.github.io/categories/Java/"}],"tags":[{"name":"小明","slug":"小明","permalink":"https://chuanwise.github.io/tags/%E5%B0%8F%E6%98%8E/"}]},{"title":"欢迎串门 (๑•̀ㅂ•́)و✧","slug":"欢迎串门 ：）","date":"2021-04-11T14:06:29.000Z","updated":"2021-04-11T16:09:34.404Z","comments":true,"path":"2021/04/11/欢迎串门 ：）/","link":"","permalink":"https://chuanwise.github.io/2021/04/11/%E6%AC%A2%E8%BF%8E%E4%B8%B2%E9%97%A8%20%EF%BC%9A%EF%BC%89/","excerpt":"","text":"椽窝 本周末抽空搭了自己的博客，起名「椽窝」，椽窝是古建筑一类非常不起眼的小窝，但对稍讲究的建筑而言不可或缺。 一直偶尔有些发些文章的需求。我注意到非常硬核，或者是分享些我在技术上的新发现或感到有趣的事情，在QQ空间获得的赞或互动比平时的说说少多了（虽然对空间的说说有这方面的「要求」听起来感觉挺小学生的，但毕竟是发到空间的当然是希望收获大家的回应），因而感到空间并不是很合适。知乎、CSDN等其他无数可以发文章的站点差不多都给我相同的感觉。而放在手机备忘录或者其他地方，并不便于必要时分享给大家。最后觉得还是搭个自己的博客最好。 所以你就看到了这一页。 从小学的时候我就一直希望未来做一个自己的网站。五年级的时候用 PS + DW 做了一个现在看起来技术很差的网站。后来对建站的热情慢慢下降。但在今天在本地测试，看到自己的博客加载出来，那种五年级时第一次看到自己的DW作品在浏览器上显示的愉快感觉马上就出现了，像是领了什么大奖。 搭建椽窝也是因为一段时间之前偶然发现了练巨的博客，在里面看了一些很有意思的上古文章。虽然更新的不勤快但每篇都像是深夜两人都不着急睡时的长谈话。这让我觉得私人搭建的博客像一个不起眼的公开日记本，偶然或定期到访的朋友会令我感到惊喜和意外。每当我输入别人的博客地址，看到关注的人的私人博客有更新的内容时，也感到高兴。这和在一些大的社交媒体平台关注的账号更新了的感受完全不一样，颇有串门的味道。 「我菜爆了」 建立博客的直接原因也是在近期高强度的编程和看文档中，综合感到我菜爆了。 大一就出了实验结果的论文，咕到大二了还没有写完。大一的高数等课基本没好好听，也没有非常努力去打 OI，在这些方向上我算是硬生生浪费了一年。 大二上半学期决定好好学习，闷声拿大分。所以平时学习也比大一认真了一大截，但是个人感觉只是在编程的量上有了变化。 虽然我有了一点点成就，例如自己写了 MC 服务器的自定义指令：CustomCommands 插件、开发了基于 Simbot 框架的可加载插件的 XiaomingBot QQ 机器人框架，但这些代码质量并不很令人满意，时常有一些 Bug 冒出来。 大二下半学期就决定闷声拿大分的同时，也提升自己的编程水平。 不过椽窝除了更新技术分享和自己项目的一些文档，我也会把这里当「公开的日记本」，发稍长些的想法和自己的总结之类的。 今天写这些吧，感谢你这次串门。","categories":[{"name":"闲聊","slug":"闲聊","permalink":"https://chuanwise.github.io/categories/%E9%97%B2%E8%81%8A/"}],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"https://chuanwise.github.io/tags/%E9%97%B2%E8%81%8A/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://chuanwise.github.io/categories/Java/"},{"name":"闲聊","slug":"闲聊","permalink":"https://chuanwise.github.io/categories/%E9%97%B2%E8%81%8A/"}],"tags":[{"name":"小明","slug":"小明","permalink":"https://chuanwise.github.io/tags/%E5%B0%8F%E6%98%8E/"},{"name":"闲聊","slug":"闲聊","permalink":"https://chuanwise.github.io/tags/%E9%97%B2%E8%81%8A/"}]}